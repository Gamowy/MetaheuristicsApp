@page "/test"
@using MetaheuristicsPlatform.Schemas
@using System.Net.Http
@using System.Net.Http.Json
@inject HttpClient Http
@rendermode InteractiveServer

<PageTitle>Metaheurystyki - testowanie</PageTitle>
<ConfirmDialog @ref="dialog" />

<h1>Testowanie wybranego algorytmu</h1>
<p class="lead">Przetestuj wybrany algorytm dla ustalonych parametrów i funkcji testowych</p>

<form>
	<p class="text-center fs-3 ">Algorytm</p>
	<div class="mb-3 border border-dark rounded p-3" id="formAlgorithm">
		@if(algorithms != null) 
		{
			<div class="mb-3 form-floating">
				<select class="form-select" id="algorithmSelect" @onchange="AlgorithmSelectionChanged">
					<option value="" selected disabled>Wybierz algorytm</option>
					@foreach (var algorithm in algorithms) 
					{
						<option value="@algorithm">@ToTitleCase(algorithm)</option>
					}
				</select>
				<label for="algorithmSelect">Algorytm optymalizacyjny</label>
			</div>

			<p class="fs-5 text-center">Parametry zewnętrzne</p>
			<div class="row">
				<div class="col">
					<p class="text-center fw-bold">Ilość iteracji</p>
				</div>
				<div class="col">
					<p class="text-center fw-bold">Rozmiar populacji</p>
				</div>
			</div>
			<div class="row">
				<div class="col">
					<div class="mb-3">
						<span class="form-text">Wartość początkowa</span>
						<NumberInput TValue="int" @bind-Value="@minI" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź wartość początkową"/>
					</div>

					<div class="mb-3">
						<span class="form-text">Wartość końcowa</span>
						<NumberInput TValue="int" @bind-Value="@maxI" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź wartość końcową"/>
					</div>

					<div class="mb-3">
						<span class="form-text">Krok</span>
						<NumberInput TValue="int" @bind-Value="@stepI" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź krok" />
					</div>
				</div>

				<div class="col">
					<div class="mb-3">
						<span class="form-text">Wartość początkowa</span>
						<NumberInput TValue="int" @bind-Value="@minN" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź wartość początkową" />
					</div>

					<div class="mb-3">
						<span class="form-text">Wartość końcowa</span>
						<NumberInput TValue="int" @bind-Value="@maxN" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź wartość końcową" />
					</div>

					<div class="mb-3">
						<span class="form-text">Krok</span>
						<NumberInput TValue="int" @bind-Value="@stepN" EnableMinMax="true" Min="1" Max="10000" Placeholder="Wprowadź krok" />
					</div>
				</div>
			</div>

			<p class="fs-5 text-center">Parametry wewnętrzne</p>
			@if (paramInfo != null && parameters != null && paramInfo.Length > 0)
			{
				@for (int i = 0; i < paramInfo.Length; i++)
				{
					int index = i;
					<div class="row mb-3">
						<div class="col">
							<span class="form-text">@paramInfo[index].Description</span>
							<NumberInput TValue="double" @bind-Value="@parameters[index]" EnableMinMax="true" 
							Min="@paramInfo[index].LowerBoundary"
							Max="@paramInfo[index].UpperBoundary"
							Step="0.1"
							Placeholder="Wprowadź wartość parametru" />
						</div>
					</div>

				}
			}
			else
			{
				<p class="mb-3 text-center">Nie znaleziono parametrów wewnętrznych</p>
			}
		}
		else 
		{
			<p class="mb-3 text-center fs-5">Nie znaleziono algorytmów...</p>
		}
	</div>

	<p class="text-center fs-3">Funkcje testowe</p>
	<div class="mb-3 border border-dark p-3" id="formAlgorithm">
		@if(fitnessFunctions != null) 
		{
			<p class="fs-5 text-center">Dostępne funkcje</p>
			@foreach (var function in fitnessFunctions)
			{
				<div class="mb-3 form-check">
					<input class="form-check-input" type="checkbox" @oninput="(ev) => FitnessFunctionCheckBoxPressed(ev, function.FunctionName)" />
					<label class="form-check-label">@ToTitleCase(function.FunctionName)</label>
				</div>
			}


			<p class="fs-5 text-center">Liczba szukanych parametrów</p>
			<span class="form-text">Maksymalna liczba szukanych parametrów</span>
			<NumberInput class="mb-3" TValue="int" @bind-Value="selectedDim" EnableMinMax="true" Min="1" Max="100" Placeholder="Wprowadź liczbę szukanych parametrów" />
		}
		else 
		{
			<p class="mb-3 text-center fs-5">Nie znaleziono funkcji testowych...</p>
		}
	</div>
	<div class="mb-3 row text-center">
		<div class="col ">
			<Button id="launchTestButton" class="d-flex mx-auto justify-content-center" Color="ButtonColor.Primary" @onclick="ShowConfirmationDialog" Size="ButtonSize.Large"
			LoadingText="&nbsp&nbspGenerowanie raportu..." Disabled="@isButtonDisabled" Loading="@isTestLaunched">
				<span class="text">Uruchom test</span>
			</Button>
		</div>
	</div>
</form>


@if (results != null)
{
	@for (int i = 0; i < results.Length; i++)
	{
		int index = i + 1;
		<div class="mb-3">
			<p>Test nr. @index</p>
			<p>Algorytm: @results[i].AlgorithmName, Funkcja testowa: @results[i].FunctionName</p>
			<p>Ilość wywołań funkcji testowej: @results[i].NumberOfEvaluationFitnessFunction</p>
			<p>XBest: @string.Join(", ", results[i].XBest), Fbest: @results[i].FBest</p>
		</div>
	}
}

@code 
{
	private string[]? algorithms;
	private ParamInfo[]? paramInfo;
	private double[]? parameters;

	private FitnessFunctionSchema[]? fitnessFunctions;

	private string? selectedAlgorithm;
	private List<string> selectedFitnessFunctions = new List<string>();
	private int selectedDim = 2;

	private int minN = 10, maxN = 40, stepN = 10;
	private int minI = 10, maxI = 40, stepI = 10;


	TestResults[]? results;
	private ConfirmDialog dialog = default!;
	private bool isTestLaunched;
	private bool isButtonDisabled { get => (selectedAlgorithm == null || selectedFitnessFunctions.Count == 0 || isTestLaunched) ? true : false; }

	protected override async Task OnInitializedAsync()
	{
		// Get algorithms
		try
		{
			algorithms = await Http.GetFromJsonAsync<string[]>("algorithms");
		}
		catch (HttpRequestException e){
			algorithms = null;
			Console.WriteLine("Failed to fetch algorithms from server: " + e.Message);
		}


		// Get fitness functions
		try
		{
			fitnessFunctions = await Http.GetFromJsonAsync<FitnessFunctionSchema[]>("functions");
		}
		catch (HttpRequestException e)
		{
			fitnessFunctions = null;
			Console.WriteLine("Failed to fetch fitness functions from server: " + e.Message);
		}
	}

	// Called when selected algorithm changes
	private async Task AlgorithmSelectionChanged(ChangeEventArgs ev) 
	{
		string algorithmName = ev?.Value?.ToString() ?? "";
		paramInfo = null;
		parameters = null;
		selectedAlgorithm = algorithmName;
		await ShowInnerParams(algorithmName);
		StateHasChanged();
	}

	private async Task ShowInnerParams(string algorithmName) 
	{
		try
		{
			paramInfo = await Http.GetFromJsonAsync<ParamInfo[]>($"algorithms/params/{algorithmName}");
			if (paramInfo != null && paramInfo.Length > 0)
			{
				parameters = new double[paramInfo.Length];
			}
		}
		catch (HttpRequestException e)
		{
			Console.WriteLine("Failed to fetch algorithm inner parameters: " + e.Message);
		}
	}

	// Called when fitness function checkbox pressed
	private void FitnessFunctionCheckBoxPressed(ChangeEventArgs ev, string functionName) 
	{
		if(!selectedFitnessFunctions.Contains(functionName))
		{
			selectedFitnessFunctions.Add(functionName);
		}
		else 
		{
			selectedFitnessFunctions.Remove(functionName);
		}
	}

	private async Task ShowConfirmationDialog() 
	{
		var confirmation = await dialog.ShowAsync(
			title: "Test algorytmu",
			message1: $"Wybrany algorytm: {ToTitleCase(selectedAlgorithm)}",
			message2: $"Przetestować algorytm dla wybranych parametrów i funkcji testowych?"
		);

		if (confirmation) 
		{
			isTestLaunched = true;
			StateHasChanged();

			await LaunchTest();

			isTestLaunched = false;
			StateHasChanged();
		}
	}

	private TestRequest[] PrepareTestRequests() 
	{
		List<TestRequest> testRequests = new List<TestRequest>();
		if (selectedAlgorithm != null && fitnessFunctions != null)
		{
			foreach (var function in fitnessFunctions)
			{
				if (selectedFitnessFunctions.Contains(function.FunctionName))
				{
					int dim = (function.AnyDims || function.Dims!.Contains(selectedDim)) ? selectedDim : function.Dims!.Max();

					for (int objects = minN; objects <= maxN; objects += stepN)
					{
						for (int iterations = minI; iterations <= maxI; iterations += stepI)
						{
							testRequests.Add(
								new TestRequest
									{
										Algorithm = selectedAlgorithm,
										N = objects,
										I = iterations,
										Fun = function.FunctionName,
										Dim = dim,
										Parameters = parameters
									}
							);
						}
					}
				}
			}
		}
		return testRequests.ToArray();
	}

	private async Task LaunchTest() 
	{
		try
		{
			TestRequest[] requests = PrepareTestRequests();
			var response = await Http.PostAsJsonAsync("/test", requests);
			results = await response.Content.ReadFromJsonAsync<TestResults[]>();
		}
		catch (Exception e) 
		{
			Console.WriteLine("Failed to launch new test: " + e.Message);
		}
	}

	private string ToTitleCase(string? str) 
	{
		return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(str ?? "");
	}
}